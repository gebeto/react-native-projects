
		<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, minimum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="./styles.css">
		<link rel="stylesheet" type="text/css" href="./prism.css">
		<script src="./prism.js"></script>
		</head><body><div class="page__inner"><main class="main main_width-limit"><article itemscope="" itemtype="http://schema.org/TechArticle"><meta content="Promise" itemprop="name"><div itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta content="iliakan@gmail.com" itemprop="email"><meta content="Ilya Kantor" itemprop="name"/></meta></div><div itemprop="articleBody"><p>Promise (обычно их так и называют «промисы») – предоставляют удобный способ организации асинхронного кода.</p>
<p>В современном JavaScript промисы часто используются в том числе и неявно, при помощи генераторов, но об этом чуть позже.</p>
<h2><a class="main__anchor" href="#что-такое-promise" name="что-такое-promise">Что такое Promise?</a></h2><p>Promise – это специальный объект, который содержит своё состояние. Вначале <code>pending</code> («ожидание»), затем – одно из: <code>fulfilled</code> («выполнено успешно») или <code>rejected</code> («выполнено с ошибкой»).</p>
<figure><div class="image" style="width:359px">
<div class="image__ratio" style="padding-top:59.888579387186624%"></div>
<img alt="" class="image__image" height="215" src="article/promise/promiseInit.png" width="359">
</img></div></figure><p>На <code>promise</code> можно навешивать коллбэки двух типов:</p>
<ul>
<li><code>onFulfilled</code> – срабатывают, когда <code>promise</code> в состоянии «выполнен успешно».</li>
<li><code>onRejected</code> – срабатывают, когда <code>promise</code> в состоянии «выполнен с ошибкой».</li>
</ul>
<p>Способ использования, в общих чертах, такой:</p>
<ol>
<li>Код, которому надо сделать что-то асинхронно, создаёт объект <code>promise</code> и возвращает его.</li>
<li>Внешний код, получив <code>promise</code>, навешивает на него обработчики.</li>
<li>По завершении процесса асинхронный код переводит <code>promise</code> в состояние <code>fulfilled</code> (с результатом) или <code>rejected</code> (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.</li>
</ol>
<p>Синтаксис создания <code>Promise</code>:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">var promise = new Promise(function(resolve, reject) {
  // Эта функция будет вызвана автоматически

  // В ней можно делать любые асинхронные операции,
  // А когда они завершатся — нужно вызвать одно из:
  // resolve(результат) при успешном выполнении
  // reject(ошибка) при ошибке
})</code></pre>
</div>
</div>
</div><p>Универсальный метод для навешивания обработчиков:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">promise.then(onFulfilled, onRejected)</code></pre>
</div>
</div>
</div><ul>
<li><code>onFulfilled</code> – функция, которая будет вызвана с результатом при <code>resolve</code>.</li>
<li><code>onRejected</code> – функция, которая будет вызвана с ошибкой при <code>reject</code>.</li>
</ul>
<p>С его помощью можно назначить как оба обработчика сразу, так и только один:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">// onFulfilled сработает при успешном выполнении
promise.then(onFulfilled)
// onRejected сработает при ошибке
promise.then(null, onRejected)</code></pre>
</div>
</div>
</div><div class="important important_smart">
<div class="important__header"><span class="important__type">.catch</span></div>
<div class="important__content"><p>Для того, чтобы поставить обработчик только на ошибку, вместо <code>.then(null, onRejected)</code> можно написать <code>.catch(onRejected)</code> – это то же самое.</p>
</div></div>
<div class="important important_smart">
<div class="important__header"><span class="important__type">Синхронный <code>throw</code> – то же самое, что <code>reject</code></span></div>
<div class="important__content"><p>Если в функции промиса происходит синхронный <code>throw</code> (или иная ошибка), то вызывается <code>reject</code>:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">'use strict';

let p = new Promise((resolve, reject) =&gt; {
  // то же что reject(new Error("o_O"))
  throw new Error("o_O");
})

p.catch(alert); // Error: o_O</code></pre>
</div>
</div>
</div></div></div>
<p>Посмотрим, как это выглядит вместе, на простом примере.</p>
<h2><a class="main__anchor" href="#пример-с-settimeout" name="пример-с-settimeout">Пример с setTimeout</a></h2><p>Возьмём <code>setTimeout</code> в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">'use strict';

// Создаётся объект promise
let promise = new Promise((resolve, reject) =&gt; {

  setTimeout(() =&gt; {
    // переведёт промис в состояние fulfilled с результатом "result"
    resolve("result");
  }, 1000);

});

// promise.then навешивает обработчики на успешный результат или ошибку
promise
  .then(
    result =&gt; {
      // первая функция-обработчик - запустится при вызове resolve
      alert("Fulfilled: " + result); // result - аргумент resolve
    },
    error =&gt; {
      // вторая функция - запустится при вызове reject
      alert("Rejected: " + error); // error - аргумент reject
    }
  );</code></pre>
</div>
</div>
</div><p>В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».</p>
<p>А если бы вместо <code>resolve("result")</code> был вызов <code>reject("error")</code>, то вывелось бы «Rejected: error». Впрочем, как правило, если при выполнении возникла проблема, то <code>reject</code> вызывают не со строкой, а с объектом ошибки типа <code>new Error</code>:</p>
<div class="code-example" data-highlight-block="4-4,12-12" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">// Этот promise завершится с ошибкой через 1 секунду
var promise = new Promise((resolve, reject) =&gt; {

  setTimeout(() =&gt; {
    reject(new Error("время вышло!"));
  }, 1000);

});

promise
  .then(
    result =&gt; alert("Fulfilled: " + result),
    error =&gt; alert("Rejected: " + error.message) // Rejected: время вышло!
  );</code></pre>
</div>
</div>
</div><p>Конечно, вместо <code>setTimeout</code> внутри функции промиса может быть и запрос к серверу и ожидание ввода пользователя, или другой асинхронный процесс. Главное, чтобы по своему завершению он вызвал <code>resolve</code> или <code>reject</code>, которые передадут результат обработчикам.</p>
<div class="important important_smart">
<div class="important__header"><span class="important__type">Только один аргумент</span></div>
<div class="important__content"><p>Функции <code>resolve/reject</code> принимают ровно один аргумент – результат/ошибку.</p>
<p>Именно он передаётся обработчикам в <code>.then</code>, как можно видеть в примерах выше.</p>
</div></div>
<h2><a class="main__anchor" href="#promise-после-reject-resolve-неизменны" name="promise-после-reject-resolve-неизменны">Promise после reject/resolve – неизменны</a></h2><p>Заметим, что после вызова <code>resolve/reject</code> промис уже не может «передумать».</p>
<p>Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда.</p>
<p>Например:</p>
<div class="code-example" data-highlight-block="4-4,7-7" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">'use strict';

let promise = new Promise((resolve, reject) =&gt; {

  // через 1 секунду готов результат: result
  setTimeout(() =&gt; resolve("result"), 1000);

  // через 2 секунды — reject с ошибкой, он будет проигнорирован
  setTimeout(() =&gt; reject(new Error("ignored")), 2000);

});

promise
  .then(
    result =&gt; alert("Fulfilled: " + result), // сработает
    error =&gt; alert("Rejected: " + error) // не сработает
  );</code></pre>
</div>
</div>
</div><p>В результате вызова этого кода сработает только первый обработчик <code>then</code>, так как после вызова <code>resolve</code> промис уже получил состояние (с результатом), и в дальнейшем его уже ничто не изменит.</p>
<p>Последующие вызовы resolve/reject  будут просто проигнорированы.</p>
<p>А так – наоборот, ошибка будет раньше:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">'use strict';

let promise = new Promise((resolve, reject) =&gt; {

  // reject вызван раньше, resolve будет проигнорирован
  setTimeout(() =&gt; reject(new Error("error")), 1000);

  setTimeout(() =&gt; resolve("ignored"), 2000);

});

promise
  .then(
    result =&gt; alert("Fulfilled: " + result), // не сработает
    error =&gt; alert("Rejected: " + error) // сработает
  );</code></pre>
</div>
</div>
</div><h2><a class="main__anchor" href="#промисификация" name="промисификация">Промисификация</a></h2><p><em>Промисификация</em> – это когда берут асинхронный функционал и делают для него обёртку, возвращающую промис.</p>
<p>После промисификации использование функционала зачастую становится гораздо удобнее.</p>
<p>В качестве примера сделаем такую обёртку для запросов при помощи XMLHttpRequest.</p>
<p>Функция <code>httpGet(url)</code> будет возвращать промис, который при успешной загрузке данных с <code>url</code> будет переходить в <code>fulfilled</code> с этими данными, а при ошибке – в <code>rejected</code> с информацией об ошибке:</p>
<div class="code-example" data-autorun="true" data-highlight-block="9-9,11-13,18-18" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">function httpGet(url) {

  return new Promise(function(resolve, reject) {

    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);

    xhr.onload = function() {
      if (this.status == 200) {
        resolve(this.response);
      } else {
        var error = new Error(this.statusText);
        error.code = this.status;
        reject(error);
      }
    };

    xhr.onerror = function() {
      reject(new Error("Network Error"));
    };

    xhr.send();
  });

}</code></pre>
</div>
</div>
</div><p>Как видно, внутри функции объект <code>XMLHttpRequest</code> создаётся и отсылается как обычно, при <code>onload/onerror</code> вызываются, соответственно, <code>resolve</code> (при статусе 200) или <code>reject</code>.</p>
<p>Использование:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">httpGet("/article/promise/user.json")
  .then(
    response =&gt; alert(`Fulfilled: ${response}`),
    error =&gt; alert(`Rejected: ${error}`)
  );</code></pre>
</div>
</div>
</div><div class="important important_smart">
<div class="important__header"><span class="important__type">Метод <code>fetch</code></span></div>
<div class="important__content"><p>Заметим, что ряд современных браузеров уже поддерживает <a href="/fetch">fetch</a> – новый встроенный метод для AJAX-запросов, призванный заменить XMLHttpRequest. Он гораздо мощнее, чем <code>httpGet</code>. И – да, этот метод использует промисы. Полифилл для него доступен на <a href="https://github.com/github/fetch">https://github.com/github/fetch</a>.</p>
</div></div>
<h2><a class="main__anchor" href="#цепочки-промисов" name="цепочки-промисов">Цепочки промисов</a></h2><p>«Чейнинг» (chaining), то есть возможность строить асинхронные цепочки из промисов – пожалуй, основная причина, из-за которой существуют и активно используются промисы.</p>
<p>Например, мы хотим по очереди:</p>
<ol>
<li>Загрузить данные посетителя с сервера (асинхронно).</li>
<li>Затем отправить запрос о нём на github (асинхронно).</li>
<li>Когда это будет готово, вывести его github-аватар на экран (асинхронно).</li>
<li>…И сделать код расширяемым, чтобы цепочку можно было легко продолжить.</li>
</ol>
<p>Вот код для этого, использующий функцию <code>httpGet</code>, описанную выше:</p>
<div class="code-example" data-highlight-block="4-4,8-8,10-10,13-13,15-15,25-25" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">'use strict';

// сделать запрос
httpGet('/article/promise/user.json')
  // 1. Получить данные о пользователе в JSON и передать дальше
  .then(response =&gt; {
    console.log(response);
    let user = JSON.parse(response);
    return user;
  })
  // 2. Получить информацию с github
  .then(user =&gt; {
    console.log(user);
    return httpGet(`https://api.github.com/users/${user.name}`);
  })
  // 3. Вывести аватар на 3 секунды (можно с анимацией)
  .then(githubUser =&gt; {
    console.log(githubUser);
    githubUser = JSON.parse(githubUser);

    let img = new Image();
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.appendChild(img);

    setTimeout(() =&gt; img.remove(), 3000); // (*)
  });</code></pre>
</div>
</div>
</div><p>Самое главное в этом коде – последовательность вызовов:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">httpGet(...)
  .then(...)
  .then(...)
  .then(...)</code></pre>
</div>
</div>
</div><p>При чейнинге, то есть последовательных вызовах <code>.then…then…then</code>, в каждый следующий <code>then</code> переходит результат от предыдущего. Вызовы <code>console.log</code> оставлены, чтобы при запуске можно было посмотреть конкретные значения, хотя они здесь и не очень важны.</p>
<p><strong>Если очередной <code>then</code> вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.</strong></p>
<p>В коде выше:</p>
<ol>
<li>Функция в первом <code>then</code> возвращает «обычное» значение <code>user</code>. Это значит, что <code>then</code> возвратит промис в состоянии «выполнен» с <code>user</code> в качестве результата. Он станет аргументом в следующем <code>then</code>.</li>
<li>Функция во втором <code>then</code> возвращает промис (результат нового вызова <code>httpGet</code>). Когда он будет завершён (может пройти какое-то время), то будет вызван следующий <code>then</code> с его результатом.</li>
<li>Третий <code>then</code> ничего не возвращает.</li>
</ol>
<p>Схематично его работу можно изобразить так:</p>
<figure><div class="image" style="width:479px">
<div class="image__ratio" style="padding-top:113.15240083507308%"></div>
<img alt="" class="image__image" height="542" src="article/promise/promiseUserFlow.png" width="479">
</img></div></figure><p>Значком «песочные часы» помечены периоды ожидания, которых всего два: в исходном <code>httpGet</code> и в подвызове далее по цепочке.</p>
<p>Если <code>then</code> возвращает промис, то до его выполнения может пройти некоторое время, оставшаяся часть цепочки будет ждать.</p>
<p>То есть, логика довольно проста:</p>
<ul>
<li>В каждом <code>then</code> мы получаем текущий результат работы.</li>
<li>Можно его обработать синхронно и вернуть результат (например, применить <code>JSON.parse</code>). Или же, если нужна асинхронная обработка – инициировать её и вернуть промис.</li>
</ul>
<p>Обратим внимание, что последний <code>then</code> в нашем примере ничего не возвращает. Если мы хотим, чтобы после <code>setTimeout</code> <code>(*)</code> асинхронная цепочка могла быть продолжена, то последний <code>then</code> тоже должен вернуть промис. Это общее правило: если внутри <code>then</code> стартует новый асинхронный процесс, то для того, чтобы оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис.</p>
<p>В данном случае промис должен перейти в состояние «выполнен» после срабатывания <code>setTimeout</code>.</p>
<p>Строку <code>(*)</code> для этого нужно переписать так:</p>
<div class="code-example" data-highlight-block="11-11" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">.then(githubUser =&gt; {
  ...

  // вместо setTimeout(() =&gt; img.remove(), 3000); (*)

  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      img.remove();
      // после таймаута — вызов resolve,
      // можно без результата, чтобы управление перешло в следующий then
      // (или можно передать данные пользователя дальше по цепочке)
      resolve();
    }, 3000);
  });
})</code></pre>
</div>
</div>
</div><p>Теперь, если к цепочке добавить ещё <code>then</code>, то он будет вызван после окончания <code>setTimeout</code>.</p>
<h2><a class="main__anchor" href="#перехват-ошибок" name="перехват-ошибок">Перехват ошибок</a></h2><p>Выше мы рассмотрели «идеальный случай» выполнения, когда ошибок нет.</p>
<p>А что, если github не отвечает? Или JSON.parse бросил синтаксическую ошибку при обработке данных?</p>
<p>Да мало ли, где ошибка…</p>
<p>Правило здесь очень простое.</p>
<p><strong>При возникновении ошибки – она отправляется в ближайший обработчик <code>onRejected</code>.</strong></p>
<p>Такой обработчик нужно поставить через второй аргумент <code>.then(..., onRejected)</code> или, что то же самое, через <code>.catch(onRejected)</code>.</p>
<p>Чтобы поймать всевозможные ошибки, которые возникнут при загрузке и обработке данных, добавим <code>catch</code> в конец нашей цепочки:</p>
<div class="code-example" data-highlight-block="2-2,21-23" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">'use strict';

// в httpGet обратимся к несуществующей странице
httpGet('/page-not-exists')
  .then(response =&gt; JSON.parse(response))
  .then(user =&gt; httpGet(`https://api.github.com/users/${user.name}`))
  .then(githubUser =&gt; {
    githubUser = JSON.parse(githubUser);

    let img = new Image();
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.appendChild(img);

    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        img.remove();
        resolve();
      }, 3000);
    });
  })
  .catch(error =&gt; {
    alert(error); // Error: Not Found
  });</code></pre>
</div>
</div>
</div><p>В примере выше ошибка возникает в первом же <code>httpGet</code>, но <code>catch</code> с тем же успехом поймал бы ошибку во втором <code>httpGet</code> или в <code>JSON.parse</code>.</p>
<p>Принцип очень похож на обычный <code>try..catch</code>: мы делаем асинхронную цепочку из <code>.then</code>, а затем, когда нужно перехватить ошибки, вызываем <code>.catch(onRejected)</code>.</p>
<div class="important important_smart">
<div class="important__header"><span class="important__type">А что после <code>catch</code>?</span></div>
<div class="important__content"><p>Обработчик <code>.catch(onRejected)</code> получает ошибку и должен обработать её.</p>
<p>Есть два варианта развития событий:</p>
<ol>
<li>Если ошибка не критичная, то <code>onRejected</code> возвращает значение через <code>return</code>, и управление переходит в ближайший <code>.then(onFulfilled)</code>.</li>
<li>Если продолжить выполнение с такой ошибкой нельзя, то он делает <code>throw</code>, и тогда ошибка переходит в следующий ближайший <code>.catch(onRejected)</code>.</li>
</ol>
<p>Это также похоже на обычный <code>try..catch</code> – в блоке <code>catch</code> ошибка либо обрабатывается, и тогда выполнение кода продолжается как обычно, либо он делает <code>throw</code>. Существенное отличие – в том, что промисы асинхронные, поэтому при отсутствии внешнего <code>.catch</code> ошибка не «вываливается» в консоль и не «убивает» скрипт.</p>
<p>Ведь возможно, что новый обработчик <code>.catch</code> будет добавлен в цепочку позже.</p>
</div></div>
<h2><a class="main__anchor" href="#промисы-в-деталях" name="промисы-в-деталях">Промисы в деталях</a></h2><p>Самым основным источником информации по промисам является, разумеется, <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise-objects">стандарт</a>.</p>
<p>Чтобы наше понимание промисов было полным, и мы могли с лёгкостью разрешать сложные ситуации, посмотрим внимательнее, что такое промис и как он работает, но уже не в общих словах, а детально, в соответствии со стандартом ECMAScript.</p>
<p>Согласно стандарту, у объекта <code>new Promise(executor)</code> при создании есть четыре внутренних свойства:</p>
<ul>
<li><code>PromiseState</code> – состояние, вначале «pending».</li>
<li><code>PromiseResult</code> – результат, при создании значения нет.</li>
<li><code>PromiseFulfillReactions</code> – список функций-обработчиков успешного выполнения.</li>
<li><code>PromiseRejectReactions</code> – список функций-обработчиков ошибки.</li>
</ul>
<figure><div class="image" style="width:333px">
<div class="image__ratio" style="padding-top:45.04504504504504%"></div>
<img alt="" class="image__image" height="150" src="article/promise/promiseEcma.png" width="333">
</img></div></figure><p>Когда функция-executor вызывает <code>reject</code> или <code>resolve</code>, то <code>PromiseState</code> становится <code>"resolved"</code> или <code>"rejected"</code>, а все функции-обработчики из соответствующего списка перемещаются в специальную системную очередь <code>"PromiseJobs"</code>.</p>
<p>Эта очередь автоматически выполняется, когда интерпретатору «нечего делать».  Иначе говоря, все функции-обработчики выполнятся асинхронно, одна за другой, по завершении текущего кода, примерно как <code>setTimeout(..,0)</code>.</p>
<p>Исключение из этого правила – если <code>resolve</code> возвращает другой <code>Promise</code>. Тогда дальнейшее выполнение ожидает его результата (в очередь помещается специальная задача), и функции-обработчики выполняются уже с ним.</p>
<p>Добавляет обработчики в списки один метод: <code>.then(onResolved, onRejected)</code>. Метод <code>.catch(onRejected)</code> – всего лишь сокращённая запись <code>.then(null, onRejected)</code>.</p>
<p>Он делает следующее:</p>
<ul>
<li>Если <code>PromiseState == "pending"</code>, то есть промис ещё не выполнен, то обработчики добавляются в соответствующие списки.</li>
<li>Иначе обработчики сразу помещаются в очередь на выполнение.</li>
</ul>
<p>Здесь важно, что обработчики можно добавлять в любой момент. Можно до выполнения промиса (они подождут), а можно – после (выполнятся в ближайшее время, через асинхронную очередь).</p>
<p>Например:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">// Промис выполнится сразу же
var promise = new Promise((resolve, reject) =&gt; resolve(1));

// PromiseState = "resolved"
// PromiseResult = 1

// Добавили обработчик к выполненному промису
promise.then(alert); // ...он сработает тут же</code></pre>
</div>
</div>
</div><p>Разумеется, можно добавлять и много обработчиков на один и тот же промис:</p>
<div class="code-example" data-highlight-block="4-4,9-9" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">// Промис выполнится сразу же
var promise = new Promise((resolve, reject) =&gt; resolve(1));

promise.then( function f1(result) {
  alert(result); // 1
  return 'f1';
})

promise.then( function f2(result) {
  alert(result); // 1
  return 'f2';
})</code></pre>
</div>
</div>
</div><p>Вид объекта <code>promise</code> после этого:</p>
<figure><div class="image" style="width:409px">
<div class="image__ratio" style="padding-top:36.674816625916876%"></div>
<img alt="" class="image__image" height="150" src="article/promise/promiseTwo.png" width="409">
</img></div></figure><p>На этой иллюстрации можно увидеть добавленные нами обработчики <code>f1</code>, <code>f2</code>, а также – автоматические добавленные обработчики ошибок <code>"Thrower"</code>.</p>
<p>Дело в том, что <code>.then</code>, если один из обработчиков не указан, добавляет его «от себя», следующим образом:</p>
<ul>
<li>Для успешного выполнения – функция <code>Identity</code>, которая выглядит как <code>arg =&gt; arg</code>, то есть возвращает аргумент без изменений.</li>
<li>Для ошибки – функция <code>Thrower</code>, которая выглядит как <code>arg =&gt; throw arg</code>, то есть генерирует ошибку.</li>
</ul>
<p>Это, по сути дела, формальность, но без неё некоторые особенности поведения промисов могут «не сойтись» в общую логику, поэтому мы упоминаем о ней здесь.</p>
<p>Обратим внимание, в этом примере намеренно <em>не используется чейнинг</em>. То есть, обработчики добавляются именно на один и тот же промис.</p>
<p>Поэтому оба <code>alert</code> выдадут одно значение <code>1</code>.</p>
<p>Все функции из списка обработчиков вызываются с результатом промиса, одна за другой. Никакой передачи результатов между обработчиками в рамках одного промиса нет, а сам результат промиса (<code>PromiseResult</code>) после установки не меняется.</p>
<p>Поэтому, чтобы продолжить работу с результатом, используется чейнинг.</p>
<p><strong>Для того, чтобы результат обработчика передать следующей функции, <code>.then</code> создаёт новый промис и возвращает его.</strong></p>
<p>В примере выше создаётся два таких промиса (т.к. два вызова <code>.then</code>), каждый из которых даёт свою ветку выполнения:</p>
<figure><div class="image" style="width:566px">
<div class="image__ratio" style="padding-top:49.293286219081274%"></div>
<img alt="" class="image__image" height="279" src="article/promise/promiseTwoThen.png" width="566">
</img></div></figure><p>Изначально эти новые промисы – «пустые», они ждут. Когда в будущем выполнятся обработчики <code>f1, f2</code>, то их результат будет передан в новые промисы по стандартному принципу:</p>
<ul>
<li>Если вернётся обычное значение (не промис), новый промис перейдёт в <code>"resolved"</code> с ним.</li>
<li>Если был <code>throw</code>, то новый промис перейдёт в состояние <code>"rejected"</code> с ошибкой.</li>
<li>Если вернётся промис, то используем его результат (он может быть как <code>resolved</code>, так и <code>rejected</code>).</li>
</ul>
<figure><div class="image" style="width:665px">
<div class="image__ratio" style="padding-top:52.63157894736842%"></div>
<img alt="" class="image__image" height="350" src="article/promise/promiseHandlerVariants.png" width="665">
</img></div></figure><p>Дальше выполнятся уже обработчики на новом промисе, и так далее.</p>
<p>Чтобы лучше понять происходящее, посмотрим на цепочку, которая получается в процессе написания кода для показа github-аватара.</p>
<p>Первый промис и обработка его результата:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">httpGet('/article/promise/user.json')
  .then(JSON.parse)</code></pre>
</div>
</div>
</div><figure><div class="image" style="width:641px">
<div class="image__ratio" style="padding-top:33.541341653666144%"></div>
<img alt="" class="image__image" height="215" src="article/promise/promiseLoadAvatarChain-1.png" width="641">
</img></div></figure><p>Если промис завершился через <code>resolve</code>, то результат – в <code>JSON.parse</code>, если <code>reject</code> – то в Thrower.</p>
<p>Как было сказано выше, <code>Thrower</code> – это стандартная внутренняя функция, которая автоматически используется, если второй обработчик не указан.</p>
<p>Можно считать, что второй обработчик выглядит так:</p>
<div class="code-example" data-highlight-inline="1:20-36" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">httpGet('/article/promise/user.json')
  .then(JSON.parse, err =&gt; throw err)</code></pre>
</div>
</div>
</div><p>Заметим, что когда обработчик в промисах делает <code>throw</code> – в данном случае, при ошибке запроса, то такая ошибка не «валит» скрипт и не выводится в консоли. Она просто будет передана в ближайший следующий обработчик <code>onRejected</code>.</p>
<p>Добавим в код ещё строку:</p>
<div class="code-example" data-highlight-block="2-2" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">httpGet('/article/promise/user.json')
  .then(JSON.parse)
  .then(user =&gt; httpGet(`https://api.github.com/users/${user.name}`))</code></pre>
</div>
</div>
</div><p>Цепочка «выросла вниз»:</p>
<figure><div class="image" style="width:641px">
<div class="image__ratio" style="padding-top:49.921996879875195%"></div>
<img alt="" class="image__image" height="320" src="article/promise/promiseLoadAvatarChain-2.png" width="641">
</img></div></figure><p>Функция <code>JSON.parse</code> либо возвращает объект с данными, либо генерирует ошибку (что расценивается как <code>reject</code>).</p>
<p>Если всё хорошо, то <code>then(user =&gt; httpGet(…))</code> вернёт новый промис, на который стоят уже два обработчика:</p>
<div class="code-example" data-highlight-block="4-11" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">httpGet('/article/promise/user.json')
  .then(JSON.parse)
  .then(user =&gt; httpGet(`https://api.github.com/users/${user.name}`))
  .then(
    JSON.parse,
    function avatarError(error) {
      if (error.code == 404) {
        return {name: "NoGithub", avatar_url: '/article/promise/anon.png'};
      } else {
        throw error;
      }
    }
  })</code></pre>
</div>
</div>
</div><figure><div class="image" style="width:641px">
<div class="image__ratio" style="padding-top:91.88767550702028%"></div>
<img alt="" class="image__image" height="589" src="article/promise/promiseLoadAvatarChain-3.png" width="641">
</img></div></figure><p>Наконец-то хоть какая-то обработка ошибок!</p>
<p>Обработчик <code>avatarError</code> перехватит ошибки, которые были ранее. Функция <code>httpGet</code> при генерации ошибки записывает её HTTP-код в свойство <code>error.code</code>, так что мы легко можем понять – что это:</p>
<ul>
<li>Если страница на Github не найдена – можно продолжить выполнение, используя «аватар по умолчанию»</li>
<li>Иначе – пробрасываем ошибку дальше.</li>
</ul>
<p>Итого, после добавления оставшейся части цепочки, картина получается следующей:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">'use strict';

httpGet('/article/promise/userNoGithub.json')
  .then(JSON.parse)
  .then(user =&gt; loadUrl(`https://api.github.com/users/${user.name}`))
  .then(
    JSON.parse,
    function githubError(error) {
      if (error.code == 404) {
        return {name: "NoGithub", avatar_url: '/article/promise/anon.png'};
      } else {
        throw error;
      }
    }
  })
  .then(function showAvatar(githubUser) {
    let img = new Image();
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.appendChild(img);
    setTimeout(() =&gt; img.remove(), 3000);
  })
  .catch(function genericError(error) {
    alert(error); // Error: Not Found
  });</code></pre>
</div>
</div>
</div><figure><div class="image" style="width:641px">
<div class="image__ratio" style="padding-top:109.36037441497659%"></div>
<img alt="" class="image__image" height="701" src="article/promise/promiseLoadAvatarChain-4.png" width="641">
</img></div></figure><p>В конце срабатывает общий обработчик <code>genericError</code>, который перехватывает любые ошибки. В данном случае ошибки, которые в него попадут, уже носят критический характер, что-то серьёзно не так. Чтобы посетитель не удивился отсутствию информации, мы показываем ему сообщение об этом.</p>
<p>Можно и как-то иначе вывести уведомление о проблеме, главное – не забыть обработать ошибки в конце. Если последнего <code>catch</code> не будет, а цепочка завершится с ошибкой, то посетитель об этом не узнает.</p>
<p>В консоли тоже ничего не будет, так как ошибка остаётся «внутри» промиса, ожидая добавления следующего обработчика <code>onRejected</code>, которому будет передана.</p>
<p>Итак, мы рассмотрели основные приёмы использования промисов. Далее – посмотрим некоторые полезные вспомогательные методы.</p>
<h2><a class="main__anchor" href="#параллельное-выполнение" name="параллельное-выполнение">Параллельное выполнение</a></h2><p>Что, если мы хотим осуществить несколько асинхронных процессов одновременно и обработать их результат?</p>
<p>В классе <code>Promise</code> есть следующие статические методы.</p>
<h3><a class="main__anchor" href="#promise-all-iterable" name="promise-all-iterable">Promise.all(iterable)</a></h3><p>Вызов <code>Promise.all(iterable)</code> получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.</p>
<p>Например:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">Promise.all([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json')
]).then(results =&gt; {
  alert(results);
});</code></pre>
</div>
</div>
</div><p>Допустим, у нас есть массив с URL.</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">let urls = [
  '/article/promise/user.json',
  '/article/promise/guest.json'
];</code></pre>
</div>
</div>
</div><p>Чтобы загрузить их параллельно, нужно:</p>
<ol>
<li>Создать для каждого URL соответствующий промис.</li>
<li>Обернуть массив таких промисов в <code>Promise.all</code>.</li>
</ol>
<p>Получится так:</p>
<div class="code-example" data-highlight-block="7-7" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">'use strict';

let urls = [
  '/article/promise/user.json',
  '/article/promise/guest.json'
];

Promise.all( urls.map(httpGet) )
  .then(results =&gt; {
    alert(results);
  });</code></pre>
</div>
</div>
</div><p>Заметим, что если какой-то из промисов завершился с ошибкой, то результатом <code>Promise.all</code> будет эта ошибка. При этом остальные промисы игнорируются.</p>
<p>Например:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">Promise.all([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json'),
  httpGet('/article/promise/no-such-page.json') // (нет такой страницы)
]).then(
  result =&gt; alert("не сработает"),
  error =&gt; alert("Ошибка: " + error.message) // Ошибка: Not Found
)</code></pre>
</div>
</div>
</div><h3><a class="main__anchor" href="#promise-race-iterable" name="promise-race-iterable">Promise.race(iterable)</a></h3><p>Вызов <code>Promise.race</code>, как и <code>Promise.all</code>, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис.</p>
<p>Но, в отличие от <code>Promise.all</code>, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.</p>
<p>Например:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">Promise.race([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json')
]).then(firstResult =&gt; {
  firstResult = JSON.parse(firstResult);
  alert( firstResult.name ); // iliakan или guest, смотря что загрузится раньше
});</code></pre>
</div>
</div>
</div><h2><a class="main__anchor" href="#promise-resolve-value" name="promise-resolve-value">Promise.resolve(value)</a></h2><p>Вызов <code>Promise.resolve(value)</code> создаёт успешно выполнившийся промис с результатом <code>value</code>.</p>
<p>Он аналогичен конструкции:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">new Promise((resolve) =&gt; resolve(value))</code></pre>
</div>
</div>
</div><p><code>Promise.resolve</code> используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть.</p>
<p>Например:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">Promise.resolve(window.location) // начать с этого значения
  .then(httpGet) // вызвать для него httpGet
  .then(alert) // и вывести результат</code></pre>
</div>
</div>
</div><h2><a class="main__anchor" href="#promise-reject-error" name="promise-reject-error">Promise.reject(error)</a></h2><p>Аналогично <code>Promise.resolve(value)</code> создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой <code>error</code>.</p>
<p>Например:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">Promise.reject(new Error("..."))
  .catch(alert) // Error: ...</code></pre>
</div>
</div>
</div><p>Метод <code>Promise.reject</code> используется очень редко, гораздо реже чем <code>resolve</code>, потому что ошибка возникает обычно не в начале цепочки, а в процессе её выполнения.</p>
<h2><a class="main__anchor" href="#итого" name="итого">Итого</a></h2><ul>
<li>Промис – это специальный объект, который хранит своё состояние, текущий результат (если есть) и коллбэки.</li>
<li>При создании <code>new Promise((resolve, reject) =&gt; ...)</code> автоматически запускается функция-аргумент, которая должна вызвать <code>resolve(result)</code> при успешном выполнении и <code>reject(error)</code> – при ошибке.</li>
<li>Аргумент <code>resolve/reject</code> (только первый, остальные игнорируются) передаётся обработчикам на этом промисе.</li>
<li>Обработчики назначаются вызовом <code>.then/catch</code>.</li>
<li>Для передачи результата от одного обработчика к другому используется чейнинг.</li>
</ul>
<p>У промисов есть некоторые ограничения. В частности, стандарт не предусматривает какой-то метод для «отмены» промиса, хотя в ряде ситуаций (http-запросы) это было бы довольно удобно. Возможно, он появится в следующей версии стандарта JavaScript.</p>
<p>В современной JavaScript-разработке сложные цепочки с промисами используются редко, так как они куда проще описываются при помощи генераторов с библиотекой <code>co</code>, которые рассмотрены в <a href="/generator">соответствующей главе</a>. Можно сказать, что промисы лежат в основе более продвинутых способов асинхронной разработки.</p>
</div></meta></article></main></div></body></html>