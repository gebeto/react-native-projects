
		<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, minimum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="./styles.css">
		<link rel="stylesheet" type="text/css" href="./prism.css">
		<script src="./prism.js"></script>
		</head><body><div class="page__inner"><main class="main main_width-limit"><article itemscope="" itemtype="http://schema.org/TechArticle"><meta content="Массив: перебирающие методы" itemprop="name"><div itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta content="iliakan@gmail.com" itemprop="email"><meta content="Ilya Kantor" itemprop="name"/></meta></div><div itemprop="articleBody"><p>Современный стандарт JavaScript предоставляет много методов для «умного» перебора массивов, которые есть в современных браузерах…</p>
<p>…Ну а для их поддержки в IE8- просто подключите библиотеку <a href="https://github.com/kriskowal/es5-shim">ES5-shim</a>.</p>
<cut>
<h2><a class="main__anchor" href="#foreach" name="foreach">forEach</a></h2><p>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach">«arr.forEach(callback[, thisArg])»</a> используется для перебора массива.</p>
<p>Он для каждого элемента массива вызывает функцию <code>callback</code>.</p>
<p>Этой функции он передаёт три параметра <code>callback(item, i, arr)</code>:</p>
<ul>
<li><code>item</code> – очередной элемент массива.</li>
<li><code>i</code> – его номер.</li>
<li><code>arr</code> – массив, который перебирается.</li>
</ul>
<p>Например:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">var arr = ["Яблоко", "Апельсин", "Груша"];

arr.forEach(function(item, i, arr) {
  alert( i + ": " + item + " (массив:" + arr + ")" );
});</code></pre>
</div>
</div>
</div><p>Второй, необязательный аргумент <code>forEach</code> позволяет указать контекст <code>this</code> для <code>callback</code>. Мы обсудим его в деталях чуть позже, сейчас он нам не важен.</p>
<p>Метод <code>forEach</code> ничего не возвращает, его используют только для перебора, как более «элегантный» вариант, чем обычный цикл <code>for</code>.</p>
<h2><a class="main__anchor" href="#filter" name="filter">filter</a></h2><p>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter">«arr.filter(callback[, thisArg])»</a> используется для <em>фильтрации</em> массива через функцию.</p>
<p>Он создаёт новый массив, в который войдут только те элементы <code>arr</code>, для которых вызов <code>callback(item, i, arr)</code> возвратит <code>true</code>.</p>
<p>Например:</p>
<div class="code-example" data-highlight-block="2-4" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">var arr = [1, -1, 2, -2, 3];

var positiveArr = arr.filter(function(number) {
  return number &gt; 0;
});

alert( positiveArr ); // 1,2,3</code></pre>
</div>
</div>
</div><h2><a class="main__anchor" href="#map" name="map">map</a></h2><p>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map">«arr.map(callback[, thisArg])»</a> используется для <em>трансформации</em> массива.</p>
<p>Он создаёт новый массив, который будет состоять из результатов вызова <code>callback(item, i, arr)</code> для каждого элемента <code>arr</code>.</p>
<p>Например:</p>
<div class="code-example" data-highlight-block="2-4" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">var names = ['HTML', 'CSS', 'JavaScript'];

var nameLengths = names.map(function(name) {
  return name.length;
});

// получили массив с длинами
alert( nameLengths ); // 4,3,10</code></pre>
</div>
</div>
</div><h2><a class="main__anchor" href="#every-some" name="every-some">every/some</a></h2><p>Эти методы используются для проверки массива.</p>
<ul>
<li>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every">«arr.every(callback[, thisArg])»</a> возвращает <code>true</code>, если вызов <code>callback</code> вернёт <code>true</code> для <em>каждого</em> элемента <code>arr</code>.</li>
<li>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some">«arr.some(callback[, thisArg])»</a> возвращает <code>true</code>, если вызов <code>callback</code> вернёт <code>true</code> для <em>какого-нибудь</em> элемента <code>arr</code>.</li>
</ul>
<div class="code-example" data-highlight-block="6-7" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">var arr = [1, -1, 2, -2, 3];

function isPositive(number) {
  return number &gt; 0;
}

alert( arr.every(isPositive) ); // false, не все положительные
alert( arr.some(isPositive) ); // true, есть хоть одно положительное</code></pre>
</div>
</div>
</div><h2><a class="main__anchor" href="#reduce-reduceright" name="reduce-reduceright">reduce/reduceRight</a></h2><p>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduce">«arr.reduce(callback[, initialValue])»</a> используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.</p>
<p>Это один из самых сложных методов для работы с массивами. Но его стоит освоить, потому что временами с его помощью можно в несколько строк решить задачу, которая иначе потребовала бы в разы больше места и времени.</p>
<p>Метод <code>reduce</code> используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива». Чуть далее мы разберём пример для вычисления суммы.</p>
<p>Он применяет функцию <code>callback</code> по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.</p>
<p>Аргументы функции <code>callback(previousValue, currentItem, index, arr)</code>:</p>
<ul>
<li><code>previousValue</code> – последний результат вызова функции, он же «промежуточный результат».</li>
<li><code>currentItem</code> – текущий элемент массива, элементы перебираются по очереди слева-направо.</li>
<li><code>index</code> – номер текущего элемента.</li>
<li><code>arr</code> – обрабатываемый массив.</li>
</ul>
<p>Кроме <code>callback</code>, методу можно передать «начальное значение» – аргумент <code>initialValue</code>. Если он есть, то на первом вызове значение <code>previousValue</code> будет равно <code>initialValue</code>, а если у <code>reduce</code> нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.</p>
<p>Проще всего понять работу метода <code>reduce</code> на примере.</p>
<p>Например, в качестве «свёртки» мы хотим получить сумму всех элементов массива.</p>
<p>Вот решение в одну строку:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">var arr = [1, 2, 3, 4, 5]

// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
var result = arr.reduce(function(sum, current) {
  return sum + current;
}, 0);

alert( result ); // 15</code></pre>
</div>
</div>
</div><p>Разберём, что в нём происходит.</p>
<p>При первом запуске <code>sum</code> – исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент <code>reduce</code>).</p>
<p>Сначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее.</p>
<p>Поток вычислений получается такой</p>
<figure><div class="image" style="width:613px">
<div class="image__ratio" style="padding-top:21.04404567699837%"></div>
<img alt="" class="image__image" height="129" src="article/array-iteration/reduce.png" width="613">
</img></div></figure><p>В виде таблицы  где каждая строка – вызов функции на очередном элементе массива:</p>
<table>
<thead>
<tr>
<th></th>
<th><code>sum</code></th>
<th><code>current</code></th>
<th>результат</th>
</tr>
</thead>
<tbody>
<tr>
<th>первый вызов</th>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
</tr>
<tr>
<th>второй вызов</th>
<td><code>1</code></td>
<td><code>2</code></td>
<td><code>3</code></td>
</tr>
<tr>
<th>третий вызов</th>
<td><code>3</code></td>
<td><code>3</code></td>
<td><code>6</code></td>
</tr>
<tr>
<th>четвёртый вызов</th>
<td><code>6</code></td>
<td><code>4</code></td>
<td><code>10</code></td>
</tr>
<tr>
<th>пятый вызов</th>
<td><code>10</code></td>
<td><code>5</code></td>
<td><code>15</code></td>
</tr>
</tbody>
</table>
<p>Как видно, результат предыдущего вызова передаётся в первый аргумент следующего.</p>
<p>Кстати, полный набор аргументов функции для <code>reduce</code> включает в себя <code>function(sum, current, i, array)</code>, то есть номер текущего вызова <code>i</code> и весь массив <code>arr</code>, но здесь в них нет нужды.</p>
<p>Посмотрим, что будет, если не указать <code>initialValue</code> в вызове <code>arr.reduce</code>:</p>
<div class="code-example" data-trusted="1">
<div class="codebox code-example__codebox">
<div class="toolbar codebox__toolbar">
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_run" data-action="run" href="#" title="выполнить"></a>
</div>
<div class="toolbar__tool">
<a class="toolbar__button toolbar__button_edit" data-action="edit" href="#" target="_blank" title="открыть в песочнице"></a>
</div>
</div>
<div class="codebox__code" data-code="1">
<pre class="line-numbers language-javascript"><code class="language-javascript">var arr = [1, 2, 3, 4, 5]

// убрали 0 в конце
var result = arr.reduce(function(sum, current) {
  return sum + current
});

alert( result ); // 15</code></pre>
</div>
</div>
</div><p>Результат – точно такой же! Это потому, что при отсутствии <code>initialValue</code> в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.</p>
<p>Таблица вычислений будет такая же, за вычетом первой строки.</p>
<p><strong>Метод <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> работает аналогично, но идёт по массиву справа-налево.</strong></p>
<h2><a class="main__anchor" href="#итого" name="итого">Итого</a></h2><p>Мы рассмотрели методы:</p>
<ul>
<li><code>forEach</code> – для <em>перебора</em> массива.</li>
<li><code>filter</code> – для <em>фильтрации</em> массива.</li>
<li><code>every/some</code> – для <em>проверки</em> массива.</li>
<li><code>map</code> – для <em>трансформации</em> массива в массив.</li>
<li><code>reduce/reduceRight</code> – для <em>прохода по массиву с вычислением значения</em>.</li>
</ul>
<p>Во многих ситуациях их использование позволяет написать код короче и понятнее, чем обычный перебор через <code>for</code>.</p>
</cut></div></meta></article></main></div></body></html>